// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';


            // These functions are ignored because they are not marked as `pub`: `map_log_level`, `now_millis`, `push_to_dart`, `sink_slot`, `to_level_filter`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `FrbRustLogger`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `enabled`, `flush`, `fmt`, `log`


            Stream<LogEntry>  createLogStream() => RustLib.instance.api.crateApiLoggingCreateLogStream();

Future<void>  installRustLogBridge({required int level }) => RustLib.instance.api.crateApiLoggingInstallRustLogBridge(level: level);

Future<void>  rustLog({required int level , required String tag , required String msg }) => RustLib.instance.api.crateApiLoggingRustLog(level: level, tag: tag, msg: msg);

Future<void>  rustLogDebug({required String tag , required String msg }) => RustLib.instance.api.crateApiLoggingRustLogDebug(tag: tag, msg: msg);

Future<void>  rustLogInfo({required String tag , required String msg }) => RustLib.instance.api.crateApiLoggingRustLogInfo(tag: tag, msg: msg);

Future<void>  rustLogWarning({required String tag , required String msg }) => RustLib.instance.api.crateApiLoggingRustLogWarning(tag: tag, msg: msg);

Future<void>  rustLogError({required String tag , required String msg }) => RustLib.instance.api.crateApiLoggingRustLogError(tag: tag, msg: msg);

Future<void>  rustLogFatal({required String tag , required String msg }) => RustLib.instance.api.crateApiLoggingRustLogFatal(tag: tag, msg: msg);

            class LogEntry  {
                final PlatformInt64 timeMillis;
final int level;
final String tag;
final String msg;

                const LogEntry({required this.timeMillis ,required this.level ,required this.tag ,required this.msg ,});

                
                

                
        @override
        int get hashCode => timeMillis.hashCode^level.hashCode^tag.hashCode^msg.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is LogEntry &&
                runtimeType == other.runtimeType
                && timeMillis == other.timeMillis&& level == other.level&& tag == other.tag&& msg == other.msg;
        
            }
            